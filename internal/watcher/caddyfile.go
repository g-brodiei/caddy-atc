package watcher

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/g-brodiei/caddy-atc/internal/config"
	"github.com/g-brodiei/caddy-atc/internal/gateway"
)

// Route represents a single reverse proxy route.
type Route struct {
	Hostname      string
	ContainerName string
	Port          string
	Project       string
	Service       string
}

// ActiveRoutes holds all currently active routes, keyed by container ID.
type ActiveRoutes struct {
	mu     sync.RWMutex
	routes map[string]*Route // keyed by container ID
}

func NewActiveRoutes() *ActiveRoutes {
	return &ActiveRoutes{
		routes: make(map[string]*Route),
	}
}

func (ar *ActiveRoutes) Add(containerID string, r *Route) {
	ar.mu.Lock()
	defer ar.mu.Unlock()
	ar.routes[containerID] = r
}

func (ar *ActiveRoutes) Remove(containerID string) {
	ar.mu.Lock()
	defer ar.mu.Unlock()
	delete(ar.routes, containerID)
}

func (ar *ActiveRoutes) Get(containerID string) (*Route, bool) {
	ar.mu.RLock()
	defer ar.mu.RUnlock()
	r, ok := ar.routes[containerID]
	return r, ok
}

func (ar *ActiveRoutes) All() []*Route {
	ar.mu.RLock()
	defer ar.mu.RUnlock()
	var routes []*Route
	for _, r := range ar.routes {
		routes = append(routes, r)
	}
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].Hostname < routes[j].Hostname
	})
	return routes
}

func (ar *ActiveRoutes) Len() int {
	ar.mu.RLock()
	defer ar.mu.RUnlock()
	return len(ar.routes)
}

// upstream holds a validated container:port pair for a reverse_proxy directive.
type upstream struct {
	Container string
	Port      string
}

// GenerateCaddyfile creates the Caddyfile content from active routes.
// Routes sharing the same hostname are grouped into a single site block
// with multiple upstreams (Caddy round-robins between them).
// All hostnames, container names, and ports are validated before interpolation.
func GenerateCaddyfile(routes *ActiveRoutes) (string, error) {
	// Group upstreams by hostname.
	grouped := make(map[string][]upstream)
	for _, r := range routes.All() {
		if err := config.ValidateHostname(r.Hostname); err != nil {
			return "", fmt.Errorf("unsafe route skipped: %w", err)
		}
		if err := config.ValidateContainerName(r.ContainerName); err != nil {
			return "", fmt.Errorf("unsafe route skipped: %w", err)
		}
		if err := config.ValidatePort(r.Port); err != nil {
			return "", fmt.Errorf("unsafe route skipped: %w", err)
		}
		grouped[r.Hostname] = append(grouped[r.Hostname], upstream{r.ContainerName, r.Port})
	}

	// Sort hostnames for deterministic output.
	hostnames := make([]string, 0, len(grouped))
	for h := range grouped {
		hostnames = append(hostnames, h)
	}
	sort.Strings(hostnames)

	var b strings.Builder
	b.WriteString("# Auto-generated by caddy-atc - do not edit manually\n")
	b.WriteString("{\n")
	b.WriteString("    local_certs\n")
	b.WriteString("    skip_install_trust\n")
	b.WriteString("}\n")

	for _, hostname := range hostnames {
		upstreams := grouped[hostname]
		addrs := make([]string, len(upstreams))
		for i, u := range upstreams {
			addrs[i] = u.Container + ":" + u.Port
		}

		b.WriteString("\n")
		b.WriteString(hostname)
		b.WriteString(" {\n")
		b.WriteString("    tls internal\n")
		fmt.Fprintf(&b, "    reverse_proxy %s\n", strings.Join(addrs, " "))
		b.WriteString("}\n")
	}

	return b.String(), nil
}

// WriteCaddyfile writes the Caddyfile to disk atomically (temp file + rename).
func WriteCaddyfile(routes *ActiveRoutes) error {
	content, err := GenerateCaddyfile(routes)
	if err != nil {
		return err
	}

	if err := config.EnsureHomeDir(); err != nil {
		return err
	}

	return atomicWriteFile(config.CaddyfilePath(), []byte(content), 0644)
}

// atomicWriteFile writes to a temp file then renames to prevent partial writes.
func atomicWriteFile(path string, data []byte, perm os.FileMode) error {
	dir := filepath.Dir(path)
	tmp, err := os.CreateTemp(dir, filepath.Base(path)+".tmp.*")
	if err != nil {
		return fmt.Errorf("creating temp file: %w", err)
	}
	tmpPath := tmp.Name()

	if _, err := tmp.Write(data); err != nil {
		tmp.Close()
		os.Remove(tmpPath)
		return fmt.Errorf("writing temp file: %w", err)
	}
	if err := tmp.Chmod(perm); err != nil {
		tmp.Close()
		os.Remove(tmpPath)
		return fmt.Errorf("setting permissions: %w", err)
	}
	if err := tmp.Close(); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("closing temp file: %w", err)
	}

	if err := os.Rename(tmpPath, path); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("renaming temp file: %w", err)
	}
	return nil
}

// ReloadCaddy tells the Caddy container to reload its config with a timeout.
func ReloadCaddy(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, "docker", "exec", gateway.ContainerName,
		"caddy", "reload", "--config", "/etc/caddy/Caddyfile")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("reloading Caddy: %w\n%s", err, string(output))
	}
	return nil
}
