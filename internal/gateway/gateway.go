package gateway

import (
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/g-brodiei/caddy-atc/internal/config"
)

const (
	NetworkName   = "caddy-atc"
	ContainerName = "caddy-atc"
)

// EnsureNetwork creates the caddy-atc Docker network if it doesn't exist.
func EnsureNetwork(ctx context.Context, cli *client.Client) error {
	networks, err := cli.NetworkList(ctx, network.ListOptions{
		Filters: filters.NewArgs(filters.Arg("name", NetworkName)),
	})
	if err != nil {
		return fmt.Errorf("listing networks: %w", err)
	}
	for _, n := range networks {
		if n.Name == NetworkName {
			return nil
		}
	}

	_, err = cli.NetworkCreate(ctx, NetworkName, network.CreateOptions{
		Driver: "bridge",
	})
	if err != nil {
		return fmt.Errorf("creating network: %w", err)
	}
	fmt.Println("Created Docker network:", NetworkName)
	return nil
}

// WriteInitialCaddyfile writes a minimal Caddyfile if none exists.
func WriteInitialCaddyfile() error {
	if err := config.EnsureHomeDir(); err != nil {
		return err
	}

	path := config.CaddyfilePath()
	if _, err := os.Stat(path); err == nil {
		return nil // already exists
	}

	content := `# Auto-generated by caddy-atc - do not edit manually
{
    local_certs
    skip_install_trust
}
`
	return os.WriteFile(path, []byte(content), 0644)
}

// Up creates the network, writes initial Caddyfile, and starts the Caddy container.
func Up(ctx context.Context) error {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("connecting to Docker: %w", err)
	}
	defer cli.Close()

	if err := EnsureNetwork(ctx, cli); err != nil {
		return err
	}

	if err := WriteInitialCaddyfile(); err != nil {
		return fmt.Errorf("writing initial Caddyfile: %w", err)
	}

	// Check if container already running
	if isContainerRunning(ctx, cli) {
		fmt.Println("Caddy gateway is already running.")
		return nil
	}

	// Write embedded compose file to temp location and run docker compose up
	tmpDir, err := os.MkdirTemp("", "caddy-atc-compose-*")
	if err != nil {
		return fmt.Errorf("creating temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	composePath := filepath.Join(tmpDir, "docker-compose.yml")
	if err := os.WriteFile(composePath, ComposeFile, 0644); err != nil {
		return fmt.Errorf("writing compose file: %w", err)
	}

	env := append(config.FilterEnv("CADDY_ATC_HOME"), "CADDY_ATC_HOME="+config.HomeDir())
	cmd := exec.CommandContext(ctx, "docker", "compose", "-f", composePath, "-p", "caddy-atc", "up", "-d")
	cmd.Env = env
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("starting Caddy container: %w", err)
	}

	fmt.Println("Caddy gateway started.")
	return nil
}

// Down stops the Caddy container.
func Down(ctx context.Context) error {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("connecting to Docker: %w", err)
	}
	defer cli.Close()

	// Stop and remove the container
	if !isContainerRunning(ctx, cli) {
		fmt.Println("Caddy gateway is not running.")
		return nil
	}

	timeout := 10
	stopOpts := container.StopOptions{Timeout: &timeout}
	if err := cli.ContainerStop(ctx, ContainerName, stopOpts); err != nil {
		return fmt.Errorf("stopping container: %w", err)
	}

	if err := cli.ContainerRemove(ctx, ContainerName, container.RemoveOptions{}); err != nil {
		// Container may auto-remove; ignore "not found" errors only
		if !strings.Contains(err.Error(), "No such container") {
			return fmt.Errorf("removing container: %w", err)
		}
	}

	fmt.Println("Caddy gateway stopped.")
	return nil
}

// IsRunning checks if the gateway is running.
func IsRunning(ctx context.Context) (bool, error) {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return false, fmt.Errorf("connecting to Docker: %w", err)
	}
	defer cli.Close()
	return isContainerRunning(ctx, cli), nil
}

// Logs streams the Caddy container logs.
func Logs(ctx context.Context, follow bool) error {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("connecting to Docker: %w", err)
	}
	defer cli.Close()

	opts := container.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     follow,
		Tail:       "100",
	}
	reader, err := cli.ContainerLogs(ctx, ContainerName, opts)
	if err != nil {
		return fmt.Errorf("getting container logs: %w", err)
	}
	defer reader.Close()

	_, err = io.Copy(os.Stdout, reader)
	return err
}

func isContainerRunning(ctx context.Context, cli *client.Client) bool {
	containers, err := cli.ContainerList(ctx, container.ListOptions{
		Filters: filters.NewArgs(filters.Arg("name", ContainerName)),
	})
	if err != nil {
		return false
	}
	for _, c := range containers {
		for _, name := range c.Names {
			if strings.TrimPrefix(name, "/") == ContainerName {
				return true
			}
		}
	}
	return false
}
